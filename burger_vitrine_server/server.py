# -*- coding: utf8 -*-
"""
This program is free software. It comes without any warranty, to
the extent permitted by applicable law. You can redistribute it
and/or modify it under the terms of the Do What The Fuck You Want
To Public License, Version 2, as published by Sam Hocevar. See
http://sam.zoy.org/wtfpl/COPYING for more details.
"""

import os
import os.path as path

import flask
import flask.ext.assets as assets

import burger_vitrine_server.resources as resources


RESOURCE_TYPES = dict((resource.PATH, resource) for resource in [
    resources.JSONResource,
    resources.HTMLResource,
    resources.BlocksResource,
    resources.ItemsResource
])


def app(instance_path=None):
    app = flask.Flask(__name__, instance_relative_config=True,
                      instance_path=instance_path)

    # Load config
    app.config.from_object("burger_vitrine_server.config")
    app.config.from_pyfile("config.cfg", silent=True)
    app.config.from_envvar("BURGER_CONFIG", silent=True)

    # Resources generated by Burger
    resources_path = mkdir_if_not_exists(app.instance_path, "resources")
    for resource_type in RESOURCE_TYPES.itervalues():
        mkdir_if_not_exists(resources_path, resource_type.PATH)
    mkdir_if_not_exists(resources_path, resources.JARResource.PATH)
    app.resources_path = resources_path

    # Minified JS and CSS files
    gen_path = mkdir_if_not_exists(app.instance_path, "gen")
    gen_blueprint = flask.Blueprint(
        "gen", __name__, static_folder=gen_path
    )
    app.register_blueprint(gen_blueprint)

    # BurgerVitrine resources
    vitrine_path = path.join(path.dirname(path.abspath(__file__)),
                             "lib", "BurgerVitrine", "resources")
    vitrine_blueprint = flask.Blueprint(
        "vitrine", __name__, static_folder=vitrine_path,
        static_url_path="/vitrine"
    )
    app.register_blueprint(vitrine_blueprint)

    # Set up webassets
    cache_path = mkdir_if_not_exists(app.instance_path, "cache")
    env = assets.Environment(app)
    env.debug = app.config.get("ASSETS_DEBUG", False)
    env.cache = cache_path
    env.directory = gen_path
    env.url = "/gen"
    env.append_path(os.path.join(os.path.dirname(os.path.abspath(__file__)),
                                 "static"), "/static")
    env.append_path(vitrine_path, "/vitrine")

    @app.before_request
    def setup():
        flask.g.versions = resources.JARResource.list()
        flask.g.left = flask.g.right = None

    @app.route("/")
    def home():
        diff = "...".join(resources.JARResource.latest(i) for i in (1, 0))
        return flask.redirect(flask.url_for('resource_guess', resource=diff))

    @app.route("/about")
    def about():
        return flask.render_template("about.html")

    @app.route("/doc")
    def doc():
        return flask.render_template("doc.html")

    @app.route("/list")
    def versions():
        versions = dict((type_name, [version[0]
                                     for version
                                     in resources.JARResource.list()
                                     if version[1] == release_type])
                        for type_name, release_type
                        in resources.JARResource.RELEASE_TYPES.iteritems()
                        if release_type is not None)
        versions["all"] = [version[0]
                           for version
                           in resources.JARResource.list()]
        return flask.jsonify(versions)

    @app.route("/<resource_type>/<resource>")
    def resource_direct(resource_type, resource):
        if u"…" in resource:
            return auto_correct_ellipsis(resource, 'resource_direct',
                                         resource_type=resource_type)
        if resource_type not in RESOURCE_TYPES:
            return flask.abort(400, "Invalid resource type")
        return display_resource(RESOURCE_TYPES[resource_type](resource))

    @app.route("/<resource>")
    def resource_guess(resource):
        if u"…" in resource:
            return auto_correct_ellipsis(resource, 'resource_guess')
        if resource.endswith(".json"):
            return display_resource(resources.JSONResource(resource[:-5]))
        if request_wants_json():
            return display_resource(resources.JSONResource(resource))
        return display_resource(resources.HTMLResource(resource))

    @app.errorhandler(resources.GenerationException)
    def generatoin_exception(e):
        return flask.render_template('generationerror.html'), 500

    @app.errorhandler(resources.NotFoundException)
    def not_found_exception(e):
        return flask.render_template('notfounderror.html'), 404

    @app.errorhandler(404)
    @app.errorhandler(400)
    def bad_request(e):
        return flask.render_template('badrequest.html'), 400

    return app


def display_resource(resource):
    if "..." in resource.name:
        flask.g.left, flask.g.right = resource.name.split("...")
    else:
        flask.g.left = resource.name
    response = flask.make_response(resource.render())
    response.mimetype = resource.MIME
    return response


def auto_correct_ellipsis(resource, redirect, **args):
    return flask.redirect(flask.url_for(
        redirect,
        resource=resource.replace(u"…", u"..."),
        **args
    ))


def request_wants_json():
    accept = flask.request.accept_mimetypes
    best = accept.best_match(['application/json', 'text/html'])
    return best == 'application/json' and accept[best] > accept['text/html']


def mkdir_if_not_exists(*parts):
    path = os.path.join(*parts)
    if not os.path.exists(path):
        os.makedirs(path)
    return path
